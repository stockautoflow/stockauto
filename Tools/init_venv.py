cd C:\StockBacktest
venv\Scripts\activate

python DataFetch_Arg.py 5 60
python backtest_loop_all_detail_refactored.py strategy 5 60 20250505
python backtest_loop_all_detail_refactored.py apex_predator_strategy 5 60 20250505
python backtest_fwV203.py strategy_EmaAdx_SlstchMacdBoll_SlStchKHistBollV203 2 5 20250504 chart 7011


#Backtest
python backtest_cli.py 5 60 20250505 --chart 1332

#Get stock data
python Tools/Convertor.py Tools/GetStockData.xlsm data_20250524

#Realtime alerter
python realtime_alerter.py

#Architecture
base.py
backtest_fw.pyを元にしたバックテストの基盤処理を担当

chart.py
OutputChart.pyを元にしたグラフ出力処理を担当

strategy.py
strategy.pyを元にしたトレード戦略の計算および決済処理を担当

backtest_cli.py
コマンドプロンプトからユーザが指定した条件に基づいてバックテストを実行する処理を担当

引数は以下の通り
実行足、環境認識足、株価データ格納フォルダ、グラフ出力有無、グラフ出力対象銘柄コード

実行例は以下の通り
python backtest_cli.py 5 60 20250505 --chart 1332
->実行足　5分足、環境認識足60分足、で1332のグラフを出力。全銘柄のDetail、Summaryも出力
python backtest_cli.py 1 5 20250505 --chart
->実行足　1分足、環境認識足５分足、で全銘柄のグラフを出力。全銘柄のDetail、Summaryも出力
python backtest_cli.py 1 5 20250505
->実行足　1分足、環境認識足５分足、でグラフ出力なし。全銘柄のDetail、Summaryを出力

config.yaml
テクニカル手法、決済に用いる時刻情報などのパラメータを定義するファイル


#Trade
トレード戦略を変更します。
以下でエントリーします。

・売り
スローストキャスティクスのSlowKとSlowD　が７０％以上、かつ
MACDのヒストグラムがピークを示して下降中

#backlog
はい、提示されているファイル構成と各ファイルの役割分担は、バックテストツールの責務を適切に分離しており、非常に良い設計です。これにより、コードの可読性、保守性、拡張性が向上します。

特に以下の点は優れていると考えられます。

* **関心の分離 (Separation of Concerns)**:
    * `backtest_cli.py`: UI（コマンドラインインターフェース）と入力バリデーションに特化。
    * `base.py`: バックテストのコアエンジン、実行フロー制御に特化。
    * `strategy.py`: 純粋なトレード戦略ロジック（指標計算、シグナル生成、決済判断）に特化。
    * `chart.py`: グラフ描画処理に特化。
    * `config.yaml`: 設定値を外部ファイルに分離。
* **再利用性と拡張性**:
    * `strategy.py` を入れ替えることで、異なる戦略を容易にテストできます。
    * `chart.py` の描画内容を変更したり、新しい描画方法を追加したりすることが、他のモジュールに影響を与えにくいです。
    * 将来的にGUIを追加する場合でも、`base.py` や `strategy.py` のコアロジックは再利用可能です。
* **テスト容易性**:
    * 各モジュールが特定の機能に集中しているため、単体テストがしやすくなります。

その上で、さらに検討できる点や、運用上考慮しておくと良い点をいくつか挙げます。

### 改善・検討の提案

1.  **設定ファイルの柔軟性向上**:
    * **`config.yaml` のパス指定**: 現在 `strategy.py` 内で `CONFIG_FILENAME = "config.yaml"` と固定されています。コマンドライン引数で `config.yaml` のパスを指定できるようにすると、複数の設定ファイルを使い分けたい場合に便利です。
        * `backtest_cli.py` で `--config <path_to_config.yaml>` のような引数を追加し、その値を `base.py` 経由で `strategy.py` に渡す（または `strategy.py` が直接読み込むパスを変更する）などの対応が考えられます。
    * **戦略モジュール名の指定**: 現在 `base.py` 内で戦略モジュール名が `'strategy'` に固定されています。異なる戦略ファイルを切り替えてテストしたい場合、これもコマンドライン引数で指定できると便利です。（`backtest_fw.py` では第一引数で指定していました）
        * `backtest_cli.py` に `--strategy-module <module_name>` のような引数を追加し、`base.py` が指定されたモジュールを動的にインポートするようにします。

2.  **データ格納フォルダの構造と銘柄リスト取得**:
    * **株価データ格納フォルダ名**: 引数で `YYYYMMDD` の日付部分を指定し、`base.py` で `CSV_OUTPUT_BASE_DIR` (`"data"`) と結合して `data_YYYYMMDD` というフォルダ名を参照しています。これは明確で良い方法です。
    * **銘柄リストの取得**: `get_codes_from_data_dir` 関数が、指定された日付のファイルがない場合にワイルドカードで代替ファイルを探すロジックは実用的です。

3.  **引数解析の厳密化 (`backtest_cli.py`)**:
    * `chart_output_flag` と `target_stock_code` の関係:
        * `python backtest_cli.py 5 60 20250505 chart 1332` (OK)
        * `python backtest_cli.py 1 5 20250505 chart` (OK)
        * `python backtest_cli.py 1 5 20250505` (OK)
        * 引数解析ロジック (`backtest_cli.py` の骨子) で、`chart_output_flag` が `None` (つまり指定なし、実行例3のケース) 
        の場合でも、その後に `target_stock_code` が指定されるとエラーにはならず、
        単に `output_chart` が `False` になるため `target_stock_code` が無視される形になっています。
        これは `argparse` の `nargs='?'` の標準的な挙動です。これで問題なければOKですが、
        もし「グラフ出力なしの場合は銘柄コードを指定できない」という制約を設けたい場合は、追加のバリデーションが必要です。
    * `target_stock_code` で複数の銘柄を指定する場合（例: `1332,1333`）、カンマ区切りで受け取り、
    リストに分割する処理を `backtest_cli.py` に入れると、より柔軟になります。
    現在の骨子では単一銘柄を想定しています。

4.  **結果の集計と詳細度**:
    * `Detail` と `Summary` のCSV出力は引き続き有用です。
    * 集計結果に、バックテスト期間や使用したパラメータ（足種など）も記録しておくと、後で見返したときにどの条件での結果かが分かりやすくなります。`Summary` CSVのヘッダー行や、別のメタ情報ファイルとして保存するなどが考えられます。

5.  **ロギングの強化 (`base.py`, `strategy.py`)**:
    * 前回の `strategy.py` のレビューでも触れましたが、`print` 文によるメッセージ出力を `logging` モジュールに統一することで、ログレベルに応じたフィルタリングや、ログフォーマットの一元管理が可能になります。
    * 特にエラー発生時や重要な分岐点でのログは、問題解決の助けになります。

6.  **エラーハンドリングと終了コード**:
    * `backtest_cli.py` で `base.py` の `run_backtest` を呼び出す際に `try-except` で囲み、
    エラー発生時に `sys.exit(1)` などで異常終了を明示するのは良い方法です。
    `base.py` 内でも、クリティカルなエラー（データフォルダが見つからない、戦略モジュールが読み込めないなど）が発生した場合は、
    適切に上位（`backtest_cli.py`）に例外を伝播させるか、そこで処理を中断する判断が必要です。

7.  **依存ライブラリの管理**:
    * `requirements.txt` ファイルを作成し、`pandas`, `numpy`, `matplotlib`, `PyYAML`, `TA-Lib` などの
    依存ライブラリとバージョンを記載しておくと、環境構築が容易になります。

### まとめ

全体として、提案されている構成は非常に堅牢で実用的です。上記の提案は、さらに使い勝手を良くしたり、長期的な運用を見据えた場合の拡張性や保守性を高めるためのものです。

特に、**設定ファイルや戦略モジュールのパスをコマンドラインから指定できるようにする**ことは、ツールの柔軟性を大きく向上させるため、優先的に検討する価値があるかもしれません。

現状の構成でも十分に機能し、責務が明確に分離されているため、開発を進めやすい状態にあると言えます。

#memo
全ての期間のチャートを各銘柄ごとにJPGファイルで出力するスクリプトを作成してください。

仕様は以下の通り

・スクリプト名　OutputChart.py

・使用方法　backtest_fw.py内でOutputChart.pyを呼び出して実行する。OutputChartを呼び出すときはbacktest_fw.pyの引数にchartを指定する。呼び出さない場合はなにも指定しない。

・チャートの仕様
ー期間　全期間
ー表示形式　
ーー1段目　環境認識のローソク足チャート、EMA、SMA、VWAP、ボリンジャーバンド、エントリー時のマーカ、利確時のマーカ、損切時のマーカ
ーー２段目　ATR、出来高
ーー３段目　環境認識のADX
ーー４段目　実行のローソク足チャート、EMA、SMA、VWAP、ボリンジャーバンド、エントリー時のマーカ、利確時のマーカ、損切時のマーカ
ーー５段目　スローストキャスティクス
ーー６段目　MACD
ーー７段目　ATR、出来高
ーチャートの色　
ーー陰線　緑
ーー陽線　赤
ーマーカの仕様
ーーエントリー時のマーカ　
ーーー買いの場合　オレンジ三角
ーーー売りの場合　黄緑逆三角
ーー利確時のマーカ
ーーー水色丸
ーー損切時のマーカ
ーーー水色バツ太線


---
Pythonスクリプトでトレード戦略のバックテストを行います。



・バックテスト用フレームワーク

backtest_fwV202.py

・トレード戦略

strategy_EmaAdx_SlstchMacdBoll_SlStchKHistBollV200.py

・チャート描画

OutputChart.py



チャート描画のOutputChart.pyを修正します。

まずは環境認識足のローソク足チャートのみを出力するようにしてください。

#------------
Real time func
#------------
#------------
Real time func proposal
#------------
バックテスト用のスクリプトを基に、リアルタイムで株価情報を読み込み、売買シグナルでアラートを出すシステムの構築、素晴らしいですね。既存のロジックを活かしつつ、リアルタイム処理に対応するためのアイディアを以下に提案します。

### 提案の柱

1.  **データ取得方法の確立**: リアルタイムまたは定期的に更新される株価データをどう手に入れるか。
2.  **実行トリガー/スケジューリング**: いつ、どのタイミングでシグナル判定処理を実行するか。
3.  **戦略ロジックの適用**: 既存の `strategy.py` をリアルタイムデータにどう適用するか。
4.  **状態管理**: 現在の市場に対するポジションや最後に処理したデータなどをどう管理するか。
5.  **アラート通知**: シグナル発生をどう知らせるか。

### アイディア詳細

#### 1. データ取得方法

* **案A：ファイル監視型**
    * **概要**: 外部プロセス（例: 定期実行されるデータダウンロードスクリプト、手動更新）が、最新の株価情報を含むCSVファイルを特定のディレクトリに配置することを想定します。このファイルは、バックテストで使用したデータ形式（`datetime`, `Open`, `High`, `Low`, `Close`, `Volume`）を踏襲すると良いでしょう。
    * **実装**: Pythonの `watchdog` ライブラリなどを使用してディレクトリを監視します。新しいファイルが作成されたり、既存ファイルが更新されたりした際にイベントを検知し、処理を開始します。
    * **メリット**: 既存の `load_csv_data` 関数（`base.py` 内 [cite: 1]）を流用しやすい可能性があります。
    * **デメリット**: ファイルの更新頻度やタイミング管理が外部依存になります。

* **案B：株価API連携型**
    * **概要**: 証券会社が提供するAPIや、他の株価情報提供サービス（Yahoo Finance API、Alpha Vantageなど）のAPIを利用して、プログラムから直接、定期的に最新の株価データを取得します。
    * **実装**: 各APIの仕様に従ってリクエストを送信し、レスポンス（JSON形式が多い）を解析してOHLCVデータに変換します。
    * **メリット**: よりリアルタイムに近いデータ取得が可能です。
    * **デメリット**: API利用料が発生する場合や、利用制限（リクエスト回数など）がある場合があります。APIの仕様変更に対応する必要があります。

#### 2. 実行トリガー/スケジューリング

* **ファイル監視型の場合**: `watchdog` がファイルイベントをトリガーとします。
* **API連携型の場合、または定期的なファイルチェックの場合**:
    * Pythonの `APScheduler` や `schedule` ライブラリを使用して、一定間隔（例: 1分ごと、5分ごと、戦略で指定した実行足インターバルごと）でシグナル判定処理を起動します。
    * OSのタスクスケジューラ（Windowsのタスクスケジューラ、Linuxのcronなど）を利用して、Pythonスクリプトを定期的に実行する方法も考えられます。

#### 3. 戦略ロジックの適用

* **入力データの準備**:
    * リアルタイムで取得した最新のバー（1本分のデータ）と、過去の一定期間のデータを組み合わせて、`strategy.py` の `calculate_indicators` 関数 が要求するDataFrameを作成します。
    * 環境認識足 (`context_interval_min`) と実行足 (`exec_interval_min`) の概念は維持します。 例えば、1分足データがリアルタイムで供給される場合、それを基にプログラム内で指定された環境認識足（例: 5分足、15分足）を動的に生成する処理が必要です。
    * 過去データは、初回起動時にある程度の期間を読み込み、以降は新しいバーが到着するたびに追加・更新していく形でメモリ（例: `pandas.DataFrame` や `collections.deque`）に保持するか、都度必要な分だけファイルやデータベースから読み込みます。

* **シグナル生成**:
    * 準備したDataFrameを `strategy.py` の `calculate_indicators` および `generate_signals` 関数に渡して、最新の売買シグナル（例: 1で買い、-1で売り、0で待機）を取得します。
    * 戦略パラメータは `config.yaml` から読み込む既存の仕組み (`load_strategy_config_yaml`) を活用します。

#### 4. 状態管理

* **監視対象銘柄ごと**に以下の情報をメモリ（例: Pythonの辞書型変数）で管理します。
    * 現在のポジション（なし, ロング, ショート）
    * エントリーした場合の価格、時刻、株数（アラートのみなら株数は不要）
    * 最後にシグナルを評価した時刻
    * 指標計算に必要な過去のOHLCVデータ（前述の通り）
* 長期間運用や複数プロセスでの運用を考える場合は、これらの状態をファイル（JSON, CSV）や簡易データベース（SQLiteなど）に永続化することも検討します。

#### 5. アラート通知

* `generate_signals` の結果、または `determine_exit_conditions`（ポジション保有時） によって新たなエントリーシグナルや決済シグナルが発生した場合にアラートを発します。
* **通知方法の例**:
    * **メール送信**: `smtplib` ライブラリを使用。
    * **デスクトップ通知**: `plyer` ライブラリ（クロスプラットフォーム）やOS固有の通知機能。
    * **チャット通知**: Slack API, Discord Webhooks, LINE Notifyなどを利用してメッセージを送信。
    * **音声通知**: `playsound` ライブラリなどで警告音を再生。
    * **コンソール出力**: シンプルに標準出力にメッセージ表示。

### 実装ステップの提案

1.  **コアロジックの分離とテスト**:
    * まず、最新の1期間分のデータと、必要な過去データを受け取って、シグナルを返す関数（`strategy.py` の関数群をラップする形）を作成します。この関数が正しく動作することを、手動で用意したデータで徹底的にテストします。
    * リアルタイムデータから実行足と環境認識足のDataFrameを適切に生成する部分が重要です。

2.  **データ取得モジュールの実装**:
    * 上記「1. データ取得方法」で選択した方式（ファイル監視 or API連携）のプロトタイプを実装します。

3.  **スケジューラとメインループの作成**:
    * `APScheduler` などを使って、定期的にデータ取得とシグナル判定を行うメインループを構築します。
    * 監視対象の銘柄リストを定義し、各銘柄に対して処理を反復します。
    * 銘柄ごとの状態管理（ポジションなど）の基本的な仕組みを実装します。

4.  **アラートモジュールの実装**:
    * まずはシンプルなコンソール出力から始め、徐々に希望の通知方法を実装します。

5.  **設定とロギング**:
    * `config.yaml` にリアルタイム処理用の設定（監視銘柄、アラート設定など）を追加できるようにします。
    * `base.py` [cite: 1] や `Convertor.py` のロギング機構を参考に、詳細なログ出力機能を組み込みます。

### 既存コードの活用ポイント

* **`strategy.py`**: 指標計算 (`calculate_indicators`)、シグナル生成 (`generate_signals`)、決済条件判断 (`determine_exit_conditions`) のロジックは中心的な役割を果たします。
* **`base.py`**: CSV読み込み (`load_csv_data`) [cite: 1] や、設定ファイルからパラメータを取得する `get_merged_param` (実際には`strategy.py`内) は流用可能です。`INITIAL_CAPITAL` などの取引前提の定数は、アラートシステムでは直接関係ないかもしれませんが、設定として残しておいても良いでしょう。 [cite: 1]
* **`config.yaml`**: 戦略パラメータ、取引時間（エントリー可能時間、強制決済時間）の設定はそのまま利用し、リアルタイム処理の制御に役立てます。

### 注意点

* **実行足と環境認識足の扱い**: バックテストと同様に、リアルタイムでも指定された異なる時間軸のデータを扱う必要があります。 例えば、1分足データを取得しつつ、それを元に5分足や15分足の環境認識足を都度生成・更新する処理が求められます。
* **取引時間の考慮**: `config.yaml` の `TRADING_HOURS` 設定を読み込み、エントリー可能時間外や市場の引け後には不要なアラートを出さないように制御します。
* **エラーハンドリング**: データ取得失敗、APIエラー、ファイル破損など、様々なエラーケースを想定し、システムが停止しないように堅牢なエラーハンドリングを実装します。
* **遅延**: データ取得の遅延や処理時間による遅延が、シグナルの鮮度に影響を与える可能性があります。
* **テスト**: 実際の市場データ（過去の短い期間の分足データなど）を使って、シグナルが期待通りに出るか、状態管理が正しく行われるかを十分にテストしてください。

これらのアイディアが、あなたの株トレード自動化システム構築の一助となれば幸いです。頑張ってください。

#------------
Real time func proposal
#------------
採用いただきありがとうございます。選択された方針に基づき、具体的な次のアクションプランを提案します。

### アクションプラン：リアルタイム株価アラートシステム構築

#### フェーズ1：準備とコア機能の実装

1.  **環境セットアップとライブラリ確認**
    * Python環境に `watchdog` ライブラリをインストールします: `pip install watchdog`
    * `requirements.txt` に `watchdog` を追記してください。
    * 既存のライブラリ (`pandas`, `numpy`, `PyYAML`, `TA-Lib`) が利用可能であることを確認します。

2.  **プロジェクト構成検討と基本ファイル作成**
    * リアルタイムアラートシステムのメインスクリプト（例: `realtime_alerter.py`）を作成します。
    * 状態を保存するJSONファイル群を格納するディレクトリ（例: `runtime_state/`）を作成します。
    * リアルタイム処理用の設定ファイル（例: `realtime_config.yaml`）を作成します。

3.  **状態管理モジュールの作成 (`state_manager.py` など)**
    * **機能**: 銘柄ごとの状態 (保有ポジション、エントリー価格、最後に処理したバーのタイムスタンプ、指標計算に必要な過去のOHLCVデータ等) をJSONファイルで永続化します。
    * **関数例**:
        * `load_state(stock_code, state_file_dir)`: 指定銘柄の状態をJSONファイルから読み込む。ファイルが存在しない場合は初期状態（例: ポジションなし、過去データ空）を返す。
        * `save_state(stock_code, state_data, state_file_dir)`: 指定銘柄の状態データをJSONファイルに保存する。
        * `get_initial_state()`: 新規銘柄用の初期状態テンプレートを返す。
    * **状態データの構造案 (例)**:
        ```json
        {
            "stock_code": "1332",
            "position": "none", // "long", "short"
            "entry_price": null,
            "entry_datetime": null,
            "last_processed_bar_datetime": "YYYY-MM-DD HH:MM:SS",
            "ohlcv_history_exec": [], // 実行足のOHLCVリスト (dequeのように一定期間保持)
            "ohlcv_history_context": [] // 環境認識足のOHLCVリスト
        }
        ```
        *履歴データは、pandas DataFrameをJSONシリアライズ可能な形式（例: `to_dict('split')`）で保存することも検討できます。*

4.  **リアルタイム用設定ファイルの定義と読み込み (`realtime_config.yaml`)**
    * **設定項目例**:
        * `data_directory_to_watch`: `watchdog` が監視する株価データファイルのディレクトリパス。
        * `state_file_directory`: `state_manager.py` がJSONファイルを保存/読み込みするディレクトリパス。
        * `watched_stock_codes`: 処理対象とする銘柄コードのリスト。
        * `email_settings`:
            * `smtp_server`: SMTPサーバーアドレス
            * `smtp_port`: SMTPサーバーポート
            * `smtp_user`: SMTPユーザー名
            * `smtp_password`: SMTPパスワード
            * `sender_email`: 送信元メールアドレス
            * `recipient_emails`: 送信先メールアドレスのリスト
    * `PyYAML` を使用してこの設定ファイルを読み込む関数を `realtime_alerter.py` 内か、別のユーティリティモジュールに作成します。

5.  **メールアラート送信モジュールの作成 (`alert_sender.py` など)**
    * **機能**: 指定された件名・本文でメールを送信します。
    * **関数例**:
        * `send_email(subject, body, recipient_emails_list, email_config)`: `smtplib` を利用してメールを送信。`email_config` にはSMTPサーバー情報などが入ります。

#### フェーズ2：データ処理と戦略ロジックの統合

6.  **データ処理と足生成ロジックの検討・実装**
    * **課題**: `watchdog` でファイル更新を検知した後、そのファイルから最新の株価データを読み込み、既存の履歴データと結合し、
    戦略で必要とされる「実行足」と「環境認識足」のDataFrameを生成する必要があります。これはバックテストのように全期間データが最初からある状況とは異なります。
    * **アプローチ**:
        1.  監視対象ファイルが更新されたら、`base.py` の `load_csv_data` を参考に（または直接利用して）データを読み込みます。 
        [cite: 1] *ファイルが追記型か、常に全期間データを含むか、最新のN件のみを含むかで読み込み後の処理が変わります。
        ここでは、ファイルにはその銘柄の全履歴、または指標計算に必要な十分な期間の履歴が含まれていると仮定します。*
        2.  読み込んだDataFrameから、`config.yaml`（またはリアルタイム設定）で指定された `exec_interval_min` と `context_interval_min` に基づいて、
        それぞれの時間軸の足をリサンプリングして生成します。 (pandasの `resample().agg({'Open':'first', 'High':'max', 'Low':'min', 'Close':'last', 'Volume':'sum'})`
                                     などが利用できます)。
        3.  生成した最新の足データを、状態管理モジュールで保持している過去の足データ(`ohlcv_history_exec`, `ohlcv_history_context`) に追加/更新します。
        指標計算に必要な期間分だけを保持するようにします（例: `collections.deque` を使うか、リストのサイズを制限する）。

#---memo
履歴データの保持:
生成した実行足と環境認識足のDataFrame全体を、状態ファイルに毎回保存するのではなく、指標計算に必要な最新のN本（または一定期間分）のデータを保持することを目標とします。
今回は簡略化のため、リサンプリングして得られたDataFrameをそのまま（あるいは一定行数に制限して）current_state に格納し、state_manager でJSONとして保存できる形式（例: to_dict('records')）に変換するアプローチを取ります。より効率的な履歴管理（例: deque の利用や差分更新）は、パフォーマンス要件に応じて将来的に改善可能です。
#---
#---memo
realtime_config.yaml と config.yaml を準備します。
重要: config.yaml に、data_processor.py がインターバル値を取得するために仮定しているキー（例: execution_interval_minutes: 5, context_interval_minutes: 15）を一時的に追加するか、data_processor.py 内の strategy_config.get(...) のキー名を config.yaml に存在する適切なキー（または realtime_config.yaml から取得する設計に変更）に合わせてください。
#---

7.  **シグナル判定ロジックの統合**
    * 上記6で準備・更新された実行足と環境認識足の履歴DataFrame（pandas DataFrame形式であること）を、`strategy.py` の `calculate_indicators` 関数に渡します。
    * その結果を `strategy.py` の `generate_signals` 関数に渡し、最新のシグナル（1, -1, 0）を取得します。
    * ポジションを保有している場合は、`strategy.py` の `determine_exit_conditions` 関数も呼び出し、決済シグナルを確認します。

#### フェーズ3：メインコントローラーとテスト

8.  **`watchdog` イベントハンドラの実装 (`realtime_alerter.py` 内)**
    * `watchdog.events.FileSystemEventHandler` を継承したカスタムハンドラクラスを作成します。
    * `on_modified` メソッド（または `on_created`）をオーバーライドします。
        * イベントが発生したファイルパスを取得します。
        * ファイル名が処理対象の銘柄の株価データファイルか（例: `銘柄コード_*.csv` のような命名規則を設ける）、または設定された監視ファイルかを判定します。
        * 対象ファイルであれば、以下の処理フローを実行します:
            1.  該当銘柄の状態を `state_manager.load_state()` で読み込みます。
            2.  上記6のデータ処理・足生成ロジックを実行します。
            3.  上記7のシグナル判定ロジックを実行します。
            4.  現在の状態（ポジション）と新しいシグナルを比較します。
                * **エントリー判断**: ポジションなしの状態で買い/売りシグナルが発生した場合。
                * **決済判断**: ポジションありの状態で反対シグナルまたは `determine_exit_conditions` による決済指示が出た場合。
            5.  シグナルに応じて `alert_sender.send_email()` を呼び出します。メール本文には、銘柄コード、日時、シグナル種別（例: 新規買い、売り決済）、価格などの情報を含めます。
            6.  処理後の新しい状態（ポジション、エントリー価格、最新の足データ履歴など）を `state_manager.save_state()` で保存します。
            7.  詳細なログを出力します（処理開始、ファイル検知、シグナル内容、状態変化、メール送信成否など）。

9.  **メイン処理の起動 (`realtime_alerter.py` 内)**
    * リアルタイム設定ファイル、`config.yaml`（戦略パラメータ用）を読み込みます。
    * `watchdog.observers.Observer` をセットアップし、カスタムイベントハンドラと監視対象ディレクトリを登録して監視を開始します。
    * プログラムが終了するまで監視を継続するループ (`try...except KeyboardInterrupt...finally observer.stop()`) を設けます。

10. **テストとデバッグ**
    * **ユニットテスト**: `state_manager.py`, `alert_sender.py`、足生成ロジックなどのコア機能が個別に正しく動作することを確認します。
    * **統合テスト**:
        * 少数の銘柄を対象に、手動で株価データファイル（バックテストで使用したCSVの一部など）を監視ディレクトリに配置・更新して、イベントハンドラが起動し、一連の処理が正しく実行されるかを確認します。
        * シグナル発生時のメール送信内容、状態のJSONファイルへの保存・読み込みが期待通りか確認します。
        * さまざまなシナリオ（新規エントリー、ドテン、利確、損切り、取引時間外の更新など）を想定してテストします。
        * ログ出力を確認し、処理の流れやエラー発生時の情報が追跡できるようにします。

このアクションプランに沿って段階的に開発を進めていくことで、要件を満たすシステムを構築できるでしょう。特にデータ処理と足の逐次生成部分、そして状態管理がリアルタイムシステムの肝となります。頑張ってください！